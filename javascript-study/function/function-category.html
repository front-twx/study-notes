<!DOCTYPE html>
<html>

<head>
  <title>构造函数与普通函数区别</title>
</head>

<body>
  <div>
    <p>Fn函数有两种执行方式： 普通函数执行，构造函数执行。</p>
    <dl>
      <dt>区别：</dt>
      <dd>普通函数将Fn执行结果返回。 构造函数将Fn当一个类，把创建的一个实例返回。</dd>
    </dl>
    <p>解析阶段：(创建全局执行上下文，变量定义、函数声明)</p>
    <dl>
      <dt>全局执行上下文进栈执行</dt>
      <dd>1、初始化变量对象</dd>
      <dd>2、初始化作用域链(window)</dd>
      <dd>3、初始化this</dd>
      <dd>4、初始化arguments</dd>
      <dd>5、形参赋值</dd>
      <dd>6、变量提升(Fn函数声明，var声明的变量)</dd>
    </dl>
    <dl>
      <dt>普通函数进栈执行</dt>
      <dd>创建函数执行上下文：初始化变量对象，初始化作用域链，初始化this, 初始化 arguments,形参赋值、变量提升</dd>
      <dd>函数由于没有返回，所以默认返回 undefined，f1 被赋值为 undefined ，在全局的 VO(G) 中 f1 = undefined</dd>
      <dd>函数执行完成出栈</dd>
    </dl>
    <dl>
      <dt>构造函数进栈执行</dt>
      <dd>创建函数执行上下文：初始化变量对象，初始化作用域链，初始化this, 初始化 arguments,形参赋值、变量提升</dd>
      <dd>函数由于没有返回，所以默认返回 undefined，f1 被赋值为 undefined ，在全局的 VO(G) 中 f1 = undefined</dd>
      <dd>函数执行完成出栈</dd>
    </dl>
  </div>
  <script>
    function Fn() {
      // ...
    }

    let f1 = Fn();
    let f2 = new Fn();

    //Fn(f1)进栈执行

    // Fn(f1) 私有上下文进栈执行
    // 初始化变量对象 AO(f1)
    // 初始化作用域链<<EC(f1), EC(G)>>
    // 初始化 this
    // 初始化 arguments
    // 形参赋值
    // 变量提升
    // 代码执行 ...
    // 函数由于没有返回，所以默认返回 undefined，f1 被赋值为 undefined ，在全局的 VO(G) 中 f1 = undefined
    // 函数执行完成出栈


    //Fn(f2) 进栈执行
    // Fn(f2) 私有上下午进栈执行
    // 初始化变量对象 AO(f2)
    // 在构造函数执行，初始化作用域链之前，浏览器会默认先创建一个对象（空对象，Fn 的实例对象）
    // 初始化作用域链<<EC(f2), EC(G)>>
    // 初始化 this，这里的初始化 this，会将 this 指向第三步创建的对象，所以在后期代码中执行 this.xx = xx 的时候，实际上就是在往这个对象(实例对象)上添加属性或者方法，这里还需要注意下，构造函数执行，函数内部的私有变量和实例是没有关系的。
    // 初始化 arguments
    // 形参赋值
    // 变量提升
    // 代码执行
    // 函数执行完，出栈之前，会查看构造函数本身的返回结果：

    // 如果有 「return 对象」，则以返回值为主，f2 就会等于这个返回值对象。
    // 如果没有返回值或者返回的是一个原始值，则浏览器默认会将创建的实例返回，f2 就会等于这个实例对
    // 函数出栈
  </script>
</body>

</html>